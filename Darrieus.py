import math
import numpy
from matplotlib import pyplot



class sourceSink:
    def __init__(self,strength,x,y):
        self.strength=strength
        self.x=x
        self.y=y

    def get_velocity(self, X, Y):
        """Returns the velocity field generated by a source/sink.
    
        Arguments
        ---------
        """
        u = self.strength/(2*numpy.pi)*(X-self.x)/((X-self.x)**2+(Y-self.y)**2)
        v = self.strength/(2*numpy.pi)*(Y-self.y)/((X-self.x)**2+(Y-self.y)**2)
    
        return [u, v]



    def get_stream_function(self, X, Y):
        """Returns the stream-function generated by a source/sink.
    
        Arguments
        ---------
        strength -- strength of the source/sink.
        xs, ys -- coordinates of the source/sink.
        X, Y -- mesh grid.
        """
        psi = self.strength/(2*numpy.pi)*numpy.arctan2((Y-self.y), (X-self.x))
    
        return psi

            

class doublet:
    def __init__(self,kappa,x,y):
        self.kappa=kappa
        self.x=x
        self.y=y

    def get_velocity(self,X,Y):
        dx=X-self.x
        dy=Y-self.y
        u=-self.kappa/(2*numpy.pi)*(dx*dx-dy*dy)/(dx**2+dy**2)**2
        v=-self.kappa/(numpy.pi)*dx*dy/(dx**2+dy**2)**2
        return [u,v]

    def get_stream_function(self,X,Y):
        dx=X-self.x
        dy=Y-self.y
        psi=-self.kappa/(2*numpy.pi)*dy/(dx**2+dy**2)**2
        return psi


class vortex:
    def __init__(self,gamma,x,y):
        self.gamma=gamma
        self.x=x
        self.y=y
    def get_velocity(self,X,Y):
        dx=X-self.x
        dy=Y-self.y
        u=self.gamma/(2*numpy.pi)*dy/((dx**2+dy**2)**2)
        v=-self.gamma/(2*numpy.pi)*dx/((dx**2+dy**2)**2)
        return [u,v]
    def get_stream_function(self,X,Y):
        dx=X-self.x
        dy=Y-self.y
        psi=self.gamma/(4*numpy.pi)*numpy.log(dx**2+dy**2)
        return psi


class freeStream:
    def __init__(self,Vinf=1.0,alpha=0.):
        self.alpha=alpha*numpy.pi/180.
        self.u=Vinf*numpy.cos(self.alpha)
        self.v=Vinf*numpy.sin(self.alpha)


class pointPale:
    def __init__(self,r,teta):
       self.x=r*numpy.cos(teta)
       self.y=r*numpy.sin(teta)
       


N = 500                                # number of points in each direction
x_start, x_end = -3.0, 3.0            # boundaries in the x-direction
y_start, y_end = -3.0, 3.0            # boundaries in the y-direction
x = numpy.linspace(x_start, x_end, N)    # creates a 1D-array with the x-coordinates
y = numpy.linspace(y_start, y_end, N)    # creates a 1D-array with the y-coordinates
Vinf=freeStream(1.5,0.)



X, Y = numpy.meshgrid(x, y)              # generates a mesh grid


u,v=Vinf.u,Vinf.v
psi=0.


s=[vortex(-3.5,0.5,-1.5),vortex(-5.2,1.,1.5)]
u,v=Vinf.u,Vinf.v



psi=0

   
#s=[doublet(5.,0.,0.)]


# plots the streamlines of the pair source/sink
size = 10

pyplot.figure(figsize=(size, (y_end-y_start)/(x_end-x_start)*size))



r0=0.75
omega=5.0
incidCible=7.0

tet=[]
inc=[]


Nv=40
teta=0.
for j in range(Nv):
    teta=2.*numpy.pi*j/Nv
    pale=pointPale(r0,teta)
    upale=-r0*omega*numpy.sin(teta)
    vpale=r0*omega*numpy.cos(teta)
    for si in s:
        ui=Vinf.u+si.get_velocity(pale.x,pale.y)[0]
        vi=si.get_velocity(pale.x,pale.y)[1]
    Urel=-upale+ui
    Vrel=-vpale+vi
    Nrel=numpy.sqrt(Urel**2+Vrel**2)
    Urel/=Nrel
    Vrel/=Nrel
    Npale=numpy.sqrt(upale**2+vpale**2)
    upale/=-Npale
    vpale/=-Npale
    cos=Urel*upale+Vrel*vpale
    sin=Urel*vpale-Vrel*upale
    incid=numpy.arctan(sin/cos)
    tet.append(teta)
    inc.append(incid*180/numpy.pi)
    xp=[pale.x,pale.x+Urel]
    yp=[pale.y,pale.y+Vrel]
    xv=[pale.x,pale.x-upale]
    yv=[pale.y,pale.y-vpale]
    pyplot.plot(xp,yp,'-r')
    pyplot.plot(xv,yv,'-b')


incOK=[]
for i in range(len(tet)):
    t=tet[i]
    if t>=numpy.pi/2 and t<=3*numpy.pi/2:
        incOK.append(inc[i])
score=(numpy.mean(incOK)-incidCible)**2.


print score





for si in s:
    u+=si.get_velocity(X, Y)[0]
    v+=si.get_velocity(X, Y)[1]
    psi+=si.get_stream_function(X, Y)


cp = 1.0 - (u**2+v**2)/(Vinf.u**2+Vinf.v**2)

pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u, v, density=4.0, linewidth=1, arrowsize=2, arrowstyle='->')
#pyplot.contourf(X,Y,cp,levels=numpy.linspace(-2.0, 1.0, 100), extend='both')
#for si in s:pyplot.scatter(si.x,si.y,color='#CD2305', s=80, marker='o', linewidth=0)

# calculates the stagnation point
x_stagnation=[]
y_stagnation=[]

#for si in s:
#    x_stagnation.append(si.x - si.strength/(2*numpy.pi*U_inf))
#    y_stagnation = y_source - strength_source/(2*numpy.pi)

# adding the stagnation point to the figure
#pyplot.scatter(x_stagnation, y_stagnation, color='g', s=80, marker='o')

# adds the dividing line to the figure
#pyplot.contour(X, Y, psi, 
#            levels=[-5.0/2, +5.0/2], 
#            colors='#CD2305', linewidths=2, linestyles='solid');


#pyplot.axis('equal')

pyplot.show()

pyplot.clf()
pyplot.plot(tet,inc)
pyplot.show()


